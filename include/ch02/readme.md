# Chapter 02

## Content

- [插入排序](###插入排序)
- [循环不变式](###循环不变式)
- [算法分析](###算法分析)
- [分治法](###分治法)
- [归并排序](###归并排序)

### 插入排序 （以正序为例）
- 插入排序是一种原址排序算法，对于少量元素的排序，它是有效的算法。
- 设一个长度为length的数组A，插入排序在逻辑上将数组分为二个部分：一部分为以排好序的，剩下的一部分为无序的。  
  排序的初始状态下两个部分为：(A\[0\])显而易见一个元素就是有序的，(A\[1\],A\[2\],A\[3\],...,A\[length-1\])无序的，
  某次迭代的状态为：(A\[0\], A\[1\],...,A\[i-1\])为有序部分，(A\[i\],A\[i+1\],...,A\[length-1\])为无序状态。
  
### 循环不变式
循环不变式主体是不变式，也就是一种描述规则的表达式。其过程分为三个部分：初始化，保持，终止。
- 初始化：  
  循环在第一次迭代之前为真
- 保持：  
  若循环的某次迭代之前为真，那么下一次迭代之前仍然为真
- 终止：  
  当循环终止的时候，不变式为我们提供一个有用的性质，该性质有助于算法是正确的
- 以插入排序为例([算法实现](./sort.hpp))：  
1. 初始化：  
  首先需要证明在循环的第一次迭代之前，循环不变式是成立的。在循环第一次迭代之前i=1,数组的有序部分(即不变式)为(A\[0\]...A\[i-1\])，
  因为i=1,所以该数组只有A\[0\]一个元素组成，显而易见是已经排序好的，所以在循环第一次迭代之前循环不变式成立。
2. 保持：  
   证明每次迭代保持循环不变式，首先看一下代码段：
   
   ```
    T key(elements[i]);
    int j = i - 1;
    while(j >= 0 && compare(elements[j], key)) {
        elements[j + 1] = elements[j];
        j--;
    }
    elements[j + 1] = key;
   ```
   这段代码会将不满足条件的A\[i-1\],A\[i-2\],A\[i-3\]等分别向右移动一个位置，直到找到A\[i\]合适的位置，让后将A\[i\]插入该位置，
   这时子数组(A\[0\], A\[1\],...,A\[i\])原来的数组(A\[0\], A\[1\],...,A\[i\])组成，但是已经按序排列。那么对在下一次迭代之前循环不变式将保持。  
3. 终止：  
   需要确定在循环终止的时候发生了什么，根据条件i<A.length可以知道在循环终止的时候i=A.length+1=n,在循环不变式中我们用n来代替i，
   可以知道子数组为：(A\[0\], A\[1\],...,A\[n-1\])由原来在(A\[0\], A\[1\],...,A\[n-1\])的元素组成，但是都已经排好序。注意到子数组
   (A\[0\], A\[1\],...,A\[n-1\])已经是整个数组，可以推断出整个数组已经排好序，因此算法正确。
   
### 算法分析
算法分析主要是分析算法所需要的资源。虽然有时候我们主要关心像内存、通信带宽或计算机硬件之类的资源，但是我们更想度量的时候算法的计算时间。
- 算法分析主要是分析计算算法时间的增长率

### 分治法
有许多有用的算法在结构上是递归的，为了解决一个给定的问题，算法一次或多次递归的调用其自身解决紧密相关的若干子问题。这些算法典型的遵循分治法的思想：
将问题分解为几个规模较小但是与原问题类似的子问题，递归的求解这些子问题，然后在合并这些子问题的结果来建立原问题的结果。  
分治模式在每层递归时都有三个步骤:  
- 分解原问题为若干子问题，这些子问题是原问题规模较小的实例。
- 解决这些子问题，递归求解各个子问题。若子问题足够小，则直接求解。
- 合并这些子问题的结果来建立原问题的解。

### 归并排序
归并排序算法完全遵循分治模式，直观上其操作如下：
- 分解：  
  把待排序的n个元素的序列分解成各具n/2个元素的两个子序列
- 解决：  
  使用归并排序递归地排序两个子序列
- 合并：  
  合并两个已排序的子序列以产生已排序的答案  

当待排序的序列长度为1的时候，递归开始回升，在这种情况下不要做任何工作，因为长度为1的序列都已排好序，归并排序算法的核心是"合并"步骤中两个已排序的子序列的
合并。我们建立一个辅助过程：设数组A，p、q、r、是数组下标，满足p <= q < r，假设子数组(A\[p\],...,A\[q\])和(A\[q+1\],...,A\[r\])都是已排好序，把
它们合并成一个已排好序的子数组(A\[p\],...,A\[r\])来替代当前的子数组。